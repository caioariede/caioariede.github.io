<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Caio Ariede on Caio Ariede</title>
    <link>//caioariede.github.io/</link>
    <description>Recent content in Caio Ariede on Caio Ariede</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 02 Mar 2018 15:57:37 -0300</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Detecting which version of Django a website is running</title>
      <link>//caioariede.github.io/posts/detecting-which-version-of-django-a-website-is-running/</link>
      <pubDate>Fri, 02 Mar 2018 15:57:37 -0300</pubDate>
      
      <guid>//caioariede.github.io/posts/detecting-which-version-of-django-a-website-is-running/</guid>
      <description>&lt;p&gt;A few days ago, before doing a job interview I was studying the current tech
stack of the company and started wondering how hard it would be to check which
version of Django they were using.&lt;/p&gt;

&lt;p&gt;I first thought it wouldn&amp;rsquo;t be trivial but I quickly figured out an easy way of
doing it. The approach is really stupid and will not work on every case, the
detection is only possible if the following requirements are met:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The project is using &lt;code&gt;django.contrib.admin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;You managed to find the path to static files (usually, /static/)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The idea is to verify the presence or absence of some files that are included
or removed between two versions. In some cases, no files were included or
removed, so in these cases I just checked for changes. I&amp;rsquo;ve ended up with two
basic checks:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;check if url exists&lt;/li&gt;
&lt;li&gt;check if url exists AND contains a certain text&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/caioariede/detect-django-version&#34;&gt;The code&lt;/a&gt; is something
like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if url_exists(url):
    return VERSION_1
elif url_contains(url):
    return VERSION_2
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With only these two checks, I was able to cover Django versions from 2.0 to 1.3.
I&amp;rsquo;ve done some tests myself and I&amp;rsquo;m frankly surprised how effective this
approach was for my tests. I was also surprised to see some websites still
using Django 1.3, damn.&lt;/p&gt;

&lt;p&gt;I used the following script to perform my tests:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from detect import detect

URLS = [
    &#39;http://example.com/static/admin&#39;,
    ...
]

for url in urls:
    print(url, detect(url))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which gave me the following output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://www.*****.com/static/admin 1.11
http://app.******.com/static/admin 1.11
http://***.********.com/static/admin 1.11
http://support.cdn.*******.net/static/admin 1.8
http://dashboard.*******.com/static/admin 1.8
http://www.*************.com/static/admin 1.4
http://********.fr/static/admin 1.4
https://*****.com/assets/admin 1.9
https://login.*****.com/site_media/admin 1.10
https://******.******.com/static/admin 1.8
http://www.*************.com/media/static/admin 1.4
http://www.*************.com/media/admin 1.3
http://********.org.uk/adminmedia 1.3
http://******.*****.it/static/admin 1.8
http://www.******.com/media/admin 1.4
http://www.*********.com/static/admin 1.6
http://www.*******************.fr/static/admin 1.4
https://www.*******.es/static/admin 1.4
https://www.****************.com/static/admin 1.10
http://*********************.de/static/admin 1.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can find the code in &lt;a href=&#34;https://github.com/caioariede/detect-django-version&#34;&gt;this repository&lt;/a&gt;.
If you want to propose an improvement, I&amp;rsquo;ll be happy to see a pull request there. :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>projects</title>
      <link>//caioariede.github.io/projects/</link>
      <pubDate>Tue, 15 Dec 2015 22:48:56 -0200</pubDate>
      
      <guid>//caioariede.github.io/projects/</guid>
      <description>

&lt;p&gt;Here you can see a little bit about my open source projects.&lt;/p&gt;

&lt;h2 id=&#34;django&#34;&gt;Django&lt;/h2&gt;

&lt;h3 id=&#34;django-location-field&#34;&gt;django-location-field&lt;/h3&gt;

&lt;p&gt;Provides a map widget where users can pick specific locations that will be
stored in the database according to the model field attached to it. The model
field can be either &lt;u&gt;plain&lt;/u&gt; or &lt;u&gt;spatial&lt;/u&gt; (when using PostGIS).&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/caioariede/django-location-field&#34;&gt;https://github.com/caioariede/django-location-field&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;django-input-mask&#34;&gt;django-input-mask&lt;/h3&gt;

&lt;p&gt;Provides a collection of form fields that can be used to mask inputs, for
decimal values, phone numbers, zip codes and so on.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/caioariede/django-input-mask&#34;&gt;https://github.com/caioariede/django-input-mask&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;openimob&#34;&gt;openimob&lt;/h3&gt;

&lt;p&gt;An open-source CMS solution for Real Estate websites on top of Wagtail.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/caioariede/openimob&#34;&gt;https://github.com/caioariede/openimob&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;python&#34;&gt;Python&lt;/h2&gt;

&lt;h3 id=&#34;pyintercept&#34;&gt;pyintercept&lt;/h3&gt;

&lt;p&gt;A tool to intercept function calls in Python scripts.&lt;/p&gt;

&lt;p&gt;Actually, I wrote a
&lt;a href=&#34;//caioariede.github.io/posts/intercepting-function-calls-in-python-scripts/&#34;&gt;blog post explaining it.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/caioariede/pyintercept&#34;&gt;https://github.com/caioariede/pyintercept&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;other&#34;&gt;Other&lt;/h2&gt;

&lt;p&gt;Mostly for fun.&lt;/p&gt;

&lt;h3 id=&#34;tpll&#34;&gt;Tpll&lt;/h3&gt;

&lt;p&gt;Implementation of the Django Template Engine in Haskell.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/caioariede/tpll&#34;&gt;https://github.com/caioariede/tpll&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>about</title>
      <link>//caioariede.github.io/about/</link>
      <pubDate>Tue, 15 Dec 2015 22:20:58 -0200</pubDate>
      
      <guid>//caioariede.github.io/about/</guid>
      <description>&lt;p&gt;I am a passionate developer doing &lt;u&gt;Python&lt;/u&gt; and &lt;u&gt;Django&lt;/u&gt; for living.&lt;/p&gt;

&lt;p&gt;This does not mean I don&amp;rsquo;t do anything else. In my day to day, I am constantly
managing &lt;u&gt;Linux servers&lt;/u&gt;, &lt;u&gt;Nginx&lt;/u&gt;, &lt;u&gt;PostgreSQL&lt;/u&gt;, &lt;u&gt;Redis&lt;/u&gt;
and so on.&lt;/p&gt;

&lt;p&gt;I love to learn new languages and contribute to open source projects, so if you
go to my &lt;a href=&#34;http://github.com/caioariede&#34;&gt;GitHub&lt;/a&gt; page, you will probably see a
mix of languages and projects. The languages I&amp;rsquo;m most interested in are:
&lt;u&gt;Python&lt;/u&gt;, &lt;u&gt;Erlang&lt;/u&gt;, &lt;u&gt;Haskell&lt;/u&gt;, &lt;u&gt;Rust&lt;/u&gt; and &lt;u&gt;Go&lt;/u&gt;.&lt;/p&gt;

&lt;p&gt;I am from Brazil, but I&amp;rsquo;ve been doing &lt;u&gt;remote work&lt;/u&gt; for some years.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:wq -- and yes, I use Vim.
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Intercepting function calls in Python scripts</title>
      <link>//caioariede.github.io/posts/intercepting-function-calls-in-python-scripts/</link>
      <pubDate>Tue, 15 Dec 2015 14:31:05 -0200</pubDate>
      
      <guid>//caioariede.github.io/posts/intercepting-function-calls-in-python-scripts/</guid>
      <description>

&lt;p&gt;This post is about &lt;a href=&#34;https://github.com/caioariede/pyintercept&#34;&gt;pyintercept&lt;/a&gt;. A
tool that I created to intercept function calls in Python scripts without
modifying its source code. It basically patches the bytecode before executing.&lt;/p&gt;

&lt;h1 id=&#34;a-little-history&#34;&gt;A little history&lt;/h1&gt;

&lt;p&gt;When I started to develop &lt;a href=&#34;http://codenizer.co/&#34;&gt;Codenizer&lt;/a&gt;, the first
challenging feature I faced was the dependency tracking. The tracking part is
almost trivial, but extracting dependencies without actually running
anything, like &lt;code&gt;python setup.py install&lt;/code&gt; is hard.&lt;/p&gt;

&lt;p&gt;I could install it in an isolated environment like Docker, and then check the
installed libraries by doing something like &lt;code&gt;pip freeze&lt;/code&gt; but I wanted to avoid
the hassle of compiling heavy-weight stuff just to know its dependencies.&lt;/p&gt;

&lt;h1 id=&#34;installation&#34;&gt;Installation&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;pip install pyintercept
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;usage&#34;&gt;Usage&lt;/h1&gt;

&lt;p&gt;This is an example of how to use pyintercept to get the
&lt;a href=&#34;http://github.com/torchbox/wagtail&#34;&gt;Wagtail&lt;/a&gt; dependencies.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/torchbox/wagtail.git # Wagtail 1.2
$ cd wagtail
$ python -m pyintercept setup.py setuptools.setup --args=install --handler=pyintercept.pdb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;setuptools.setup&lt;/code&gt; is the dotted path to the function we want to intercept&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--args=install&lt;/code&gt; is used to pass arguments to the script (&lt;code&gt;setup.py&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--handler=pyintercept.pdb&lt;/code&gt; is used to set the handler you want. There are
some predefined handlers: &lt;code&gt;json&lt;/code&gt;, &lt;code&gt;pdb&lt;/code&gt;, &lt;code&gt;pickle&lt;/code&gt; and &lt;code&gt;print&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It will drop you in a pdb console:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(Pdb) l
1  	def pdb(origfn, *args, **kwargs):
2  	    import pdb; pdb.set_trace()
3  -&amp;gt;       return origfn(*args, **kwargs)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;(Pdb) p origfn
&amp;lt;function setup at 0x1020ed9b0&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;(Pdb) from pprint import pprint
(Pdb) pprint(kwargs[&#39;install_requires&#39;])
[&#39;Django&amp;gt;=1.7.1,&amp;lt;1.10&#39;,
&#39;django-compressor&amp;gt;=1.4&#39;,
&#39;django-modelcluster&amp;gt;=1.0&#39;,
&#39;django-taggit&amp;gt;=0.17.5&#39;,
&#39;django-treebeard==3.0&#39;,
&#39;djangorestframework&amp;gt;=3.1.3&#39;,
&#39;Pillow&amp;gt;=2.6.1&#39;,
&#39;beautifulsoup4&amp;gt;=4.3.2&#39;,
&#39;html5lib&amp;gt;=0.999,&amp;lt;1&#39;,
&#39;Unidecode&amp;gt;=0.04.14&#39;,
&#39;Willow&amp;gt;=0.2.2,&amp;lt;0.3&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Okay, so we just intercepted the call to &lt;code&gt;setuptools.setup&lt;/code&gt; without touching
any code. The &lt;code&gt;origfn&lt;/code&gt; argument contains the original function. The &lt;code&gt;*args&lt;/code&gt; and
&lt;code&gt;**kwargs&lt;/code&gt; contains the arguments that would be passed to the original
function.&lt;/p&gt;

&lt;h2 id=&#34;advanced-usage&#34;&gt;Advanced usage&lt;/h2&gt;

&lt;h3 id=&#34;defining-a-custom-handler&#34;&gt;Defining a custom handler&lt;/h3&gt;

&lt;p&gt;You can also, of course, write your own handlers. Let&amp;rsquo;s write a custom handler
that prints out to stdout all requirements in JSON format.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s call it &lt;code&gt;amazing.py&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def handler(*args, **kwargs):
    import json
    print(json.dumps(kwargs.get(&#39;install_requires&#39;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;python -m pyintercept setup.py setuptools.setup --args=install --handler=amazing.handler
[&amp;quot;Django&amp;gt;=1.7.1,&amp;lt;1.10&amp;quot;, &amp;quot;django-compressor&amp;gt;=1.4&amp;quot;, &amp;quot;django-modelcluster&amp;gt;=1.0&amp;quot;, &amp;quot;django-taggit&amp;gt;=0.17.5&amp;quot;, &amp;quot;django-treebeard==3.0&amp;quot;, &amp;quot;djangorestframework&amp;gt;=3.1.3&amp;quot;, &amp;quot;Pillow&amp;gt;=2.6.1&amp;quot;, &amp;quot;beautifulsoup4&amp;gt;=4.3.2&amp;quot;, &amp;quot;html5lib&amp;gt;=0.999,&amp;lt;1&amp;quot;, &amp;quot;Unidecode&amp;gt;=0.04.14&amp;quot;, &amp;quot;Willow&amp;gt;=0.2.2,&amp;lt;0.3&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s important to notice the &lt;code&gt;import&lt;/code&gt; statement inside the handler function.
You&amp;rsquo;ll have to ensure that all the required stuff to make your handler work is
defined within it, otherwise it will not be injected and will cause errors.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
