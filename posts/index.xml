<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Caio Ariede</title>
    <link>//caioariede.github.io/posts/</link>
    <description>Recent content in Posts on Caio Ariede</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 15 Dec 2015 14:31:05 -0200</lastBuildDate>
    <atom:link href="//caioariede.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Intercepting function calls in Python scripts</title>
      <link>//caioariede.github.io/posts/intercepting-function-calls-in-python-scripts/</link>
      <pubDate>Tue, 15 Dec 2015 14:31:05 -0200</pubDate>
      
      <guid>//caioariede.github.io/posts/intercepting-function-calls-in-python-scripts/</guid>
      <description>

&lt;p&gt;This post is about &lt;a href=&#34;https://github.com/caioariede/pyintercept&#34;&gt;pyintercept&lt;/a&gt;. A
tool that I created to intercept function calls in Python scripts without
modifying its source code. It basically patches the bytecode before executing
it.&lt;/p&gt;

&lt;h1 id=&#34;a-little-history:7fbaffeb3a450392adbb81457420bdce&#34;&gt;A little history&lt;/h1&gt;

&lt;p&gt;When I started to develop &lt;a href=&#34;http://codenizer.co/&#34;&gt;Codenizer&lt;/a&gt;, the first
challenging feature I faced was the dependency tracking. The tracking part is
almost trivial, but extracting dependencies without actually running
anything, like &lt;code&gt;python setup.py install&lt;/code&gt; is hard.&lt;/p&gt;

&lt;p&gt;I could install it in an isolated environment like Docker, and then check the
installed libraries by doing something like &lt;code&gt;pip freeze&lt;/code&gt; but I wanted to avoid
the hassle of compiling heavy-weight stuff just to know its dependencies.&lt;/p&gt;

&lt;h1 id=&#34;installation:7fbaffeb3a450392adbb81457420bdce&#34;&gt;Installation&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;pip install pyintercept
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;usage:7fbaffeb3a450392adbb81457420bdce&#34;&gt;Usage&lt;/h1&gt;

&lt;p&gt;This is an example on how to use pyintercept to get the
&lt;a href=&#34;http://github.com/torchbox/wagtail&#34;&gt;Wagtail&lt;/a&gt; dependencies.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/torchbox/wagtail.git # Wagtail 1.2
$ cd wagtail
$ python -m pyintercept setup.py setuptools.setup --args=install --handler=pyintercept.pdb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;setuptools.setup&lt;/code&gt; is the dotted path to the function will want to intercept&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--args=install&lt;/code&gt; is used to pass arguments to the script (&lt;code&gt;setup.py&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--handler=pyintercept.pdb&lt;/code&gt; is used to set the handler you want. There are
some predefined handlers: &lt;code&gt;json&lt;/code&gt;, &lt;code&gt;pdb&lt;/code&gt;, &lt;code&gt;pickle&lt;/code&gt; and &lt;code&gt;print&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Will drop you in a pdb console:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(Pdb) l
1  	def pdb(origfn, *args, **kwargs):
2  	    import pdb; pdb.set_trace()
3  -&amp;gt;       return origfn(*args, **kwargs)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;(Pdb) p origfn
&amp;lt;function setup at 0x1020ed9b0&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;(Pdb) from pprint import pprint
(Pdb) pprint(kwargs[&#39;install_requires&#39;])
[&#39;Django&amp;gt;=1.7.1,&amp;lt;1.10&#39;,
&#39;django-compressor&amp;gt;=1.4&#39;,
&#39;django-modelcluster&amp;gt;=1.0&#39;,
&#39;django-taggit&amp;gt;=0.17.5&#39;,
&#39;django-treebeard==3.0&#39;,
&#39;djangorestframework&amp;gt;=3.1.3&#39;,
&#39;Pillow&amp;gt;=2.6.1&#39;,
&#39;beautifulsoup4&amp;gt;=4.3.2&#39;,
&#39;html5lib&amp;gt;=0.999,&amp;lt;1&#39;,
&#39;Unidecode&amp;gt;=0.04.14&#39;,
&#39;Willow&amp;gt;=0.2.2,&amp;lt;0.3&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We just intercepted the call to &lt;code&gt;setuptools.setup&lt;/code&gt; without modifying any source
code. The &lt;code&gt;origfn&lt;/code&gt; argument contains the original function. The &lt;code&gt;*args&lt;/code&gt; and
&lt;code&gt;**kwargs&lt;/code&gt; contains the arguments that would be passed to the original
function.&lt;/p&gt;

&lt;h2 id=&#34;advanced-usage:7fbaffeb3a450392adbb81457420bdce&#34;&gt;Advanced usage&lt;/h2&gt;

&lt;h3 id=&#34;defining-a-custom-handler:7fbaffeb3a450392adbb81457420bdce&#34;&gt;Defining a custom handler&lt;/h3&gt;

&lt;p&gt;You can also, of course, write your own handlers. Let&amp;rsquo;s write a custom handler
that prints out to stdout all requirements in JSON format.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s call it &lt;code&gt;amazing.py&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def handler(*args, **kwargs):
    import json
    print(json.dumps(kwargs.get(&#39;install_requires&#39;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;python -m pyintercept setup.py setuptools.setup --args=install --handler=amazing.handler
[&amp;quot;Django&amp;gt;=1.7.1,&amp;lt;1.10&amp;quot;, &amp;quot;django-compressor&amp;gt;=1.4&amp;quot;, &amp;quot;django-modelcluster&amp;gt;=1.0&amp;quot;, &amp;quot;django-taggit&amp;gt;=0.17.5&amp;quot;, &amp;quot;django-treebeard==3.0&amp;quot;, &amp;quot;djangorestframework&amp;gt;=3.1.3&amp;quot;, &amp;quot;Pillow&amp;gt;=2.6.1&amp;quot;, &amp;quot;beautifulsoup4&amp;gt;=4.3.2&amp;quot;, &amp;quot;html5lib&amp;gt;=0.999,&amp;lt;1&amp;quot;, &amp;quot;Unidecode&amp;gt;=0.04.14&amp;quot;, &amp;quot;Willow&amp;gt;=0.2.2,&amp;lt;0.3&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s important to notice the &lt;code&gt;import&lt;/code&gt; statement inside the handler function.
You have to ensure that all the required stuff to make your handler work must
be defined within it, otherwise it will not be injected and will cause errors.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>